// Score submission utilities - encryption handled server-side

// Physics-based floating elements with space-like movement
class FloatingElement {
    constructor(emoji, x, y, size = 'medium') {
        this.emoji = emoji;
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.size = size;
        this.element = null;
        this.mass = size === 'large' ? 4 : size === 'small' ? 1 : 2;
        this.radius = size === 'large' ? 25 : size === 'small' ? 15 : 20;
        this.maxSpeed = size === 'large' ? 3 : size === 'small' ? 5 : 4;
        this.mouseRepelForce = size === 'large' ? 50000 : size === 'small' ? 60000 : 55000;
        this.mouseRepelDistance = size === 'large' ? 150 : size === 'small' ? 100 : 120;
        
        this.createElement();
    }
    
    createElement() {
        this.element = document.createElement('div');
        this.element.className = `floating-element ${this.size}`;
        this.element.textContent = this.emoji;
        this.element.style.left = this.x + 'px';
        this.element.style.top = this.y + 'px';
        this.element.style.position = 'absolute';
        this.element.style.zIndex = '5';
        this.element.style.pointerEvents = 'none';
        
        const container = document.getElementById('floatingContainer');
        if (container) {
            container.appendChild(this.element);
            // Reduce console logging for performance
            // console.log('Created floating element:', this.emoji, 'at', this.x, this.y);
        } else {
            console.error('floatingContainer not found!');
        }
    }
    
    update(mouseX, mouseY, otherElements) {
        // Mouse repulsion - optimize distance calculation
        const mouseDx = this.x - mouseX;
        const mouseDy = this.y - mouseY;
        const mouseDistanceSquared = mouseDx * mouseDx + mouseDy * mouseDy;
        const mouseRepelDistanceSquared = this.mouseRepelDistance * this.mouseRepelDistance;
        
        if (mouseDistanceSquared < mouseRepelDistanceSquared && mouseDistanceSquared > 0) {
            // Only calculate sqrt when needed
            const mouseDistance = Math.sqrt(mouseDistanceSquared);
            const mouseForce = this.mouseRepelForce / (mouseDistance * 100);
            const mouseNormalX = mouseDx / mouseDistance;
            const mouseNormalY = mouseDy / mouseDistance;
            this.vx += mouseNormalX * mouseForce;
            this.vy += mouseNormalY * mouseForce;
        }
        
        // Element-to-element collisions - optimize with early exit
        for (let i = 0; i < otherElements.length; i++) {
            const other = otherElements[i];
            if (other === this || other.isInteractive) continue;
            
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = this.radius + other.radius;
            const minDistanceSquared = minDistance * minDistance;
            
            if (distanceSquared < minDistanceSquared && distanceSquared > 0) {
                // Only calculate sqrt for actual collisions
                const distance = Math.sqrt(distanceSquared);
                const overlap = minDistance - distance;
                const separation = overlap / 2;
                
                // Normalize direction
                const normalX = dx / distance;
                const normalY = dy / distance;
                
                // Separate elements
                this.x += normalX * separation;
                this.y += normalY * separation;
                other.x -= normalX * separation;
                other.y -= normalY * separation;
                
                // Calculate relative velocity
                const relativeVx = this.vx - other.vx;
                const relativeVy = this.vy - other.vy;
                
                // Calculate relative velocity in collision normal direction
                const relativeSpeed = relativeVx * normalX + relativeVy * normalY;
                
                // Do not resolve if velocities are separating
                if (relativeSpeed > 0) continue;
                
                // Calculate restitution (bounciness)
                const restitution = 0.8;
                
                // Calculate impulse
                const impulse = -(1 + restitution) * relativeSpeed / (1/this.mass + 1/other.mass);
                
                // Apply impulse
                const impulseX = impulse * normalX;
                const impulseY = impulse * normalY;
                
                this.vx += impulseX / this.mass;
                this.vy += impulseY / this.mass;
                other.vx -= impulseX / other.mass;
                other.vy -= impulseY / other.mass;
            }
        }
        
        // Apply movement
        this.x += this.vx;
        this.y += this.vy;
        
        // Speed limiting
        const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
        if (speed > this.maxSpeed) {
            this.vx = (this.vx / speed) * this.maxSpeed;
            this.vy = (this.vy / speed) * this.maxSpeed;
        }
        
        // Boundary bouncing with energy conservation
        const margin = this.radius;
        if (this.x < margin) {
            this.x = margin;
            this.vx = Math.abs(this.vx) * 0.9; // Energy loss on bounce
        }
        if (this.x > window.innerWidth - margin) {
            this.x = window.innerWidth - margin;
            this.vx = -Math.abs(this.vx) * 0.9;
        }
        if (this.y < margin) {
            this.y = margin;
            this.vy = Math.abs(this.vy) * 0.9;
        }
        if (this.y > window.innerHeight - margin) {
            this.y = window.innerHeight - margin;
            this.vy = -Math.abs(this.vy) * 0.9;
        }
        
        // Add slight random movement to keep things interesting
        if (Math.random() < 0.002) {
            this.vx += (Math.random() - 0.5) * 0.2;
            this.vy += (Math.random() - 0.5) * 0.2;
        }
        
        // Batch DOM updates - only update if position changed significantly
        const deltaX = Math.abs(this.x - (this.lastX || this.x));
        const deltaY = Math.abs(this.y - (this.lastY || this.y));
        
        // Force update on first frame or if position changed significantly
        if (!this.lastX || !this.lastY || deltaX > 0.5 || deltaY > 0.5) {
            this.element.style.left = this.x + 'px';
            this.element.style.top = this.y + 'px';
            
            // Add rotation based on velocity for extra visual appeal
            const rotation = Math.atan2(this.vy, this.vx) * (180 / Math.PI);
            this.element.style.transform = `rotate(${rotation * 0.1}deg)`;
            
            this.lastX = this.x;
            this.lastY = this.y;
        }
    }
}

// Base class for interactive elements (LinkedIn, GitHub, etc.)
class InteractiveElement extends FloatingElement {
    constructor(type, x, y) {
        super('üîó', x, y, 'medium'); // Placeholder emoji
        this.isInteractive = true;
        this.type = type;
        this.maxSpeed = 1.5; // Much slower movement
        this.mass = 10; // Heavy so it affects others more
        this.radius = 30; // Larger radius for more influence
        this.angle = Math.random() * Math.PI * 2; // For smooth circular-ish movement
        this.speedMultiplier = 0.3; // Very slow movement
        
        // Orbiting state
        this.isOrbiting = false;
        this.orbitTarget = { x: 0, y: 0 };
        this.orbitRadius = 80 + Math.random() * 40; // Random orbit radius between 80-120px
        this.orbitSpeed = 0.02 + Math.random() * 0.01; // Random orbit speed
        this.orbitAngle = Math.random() * Math.PI * 2; // Random starting orbit position
        this.originalPosition = { x: this.x, y: this.y };
        this.moveToOrbitSpeed = 0.1; // Speed when moving to orbit position
        this.orbitCenterLocked = false; // Whether orbit center is locked in place
        
        // Override the createElement based on type
        this.createInteractiveElement();
    }
    
    createInteractiveElement() {
        // Remove the default element first
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        
        this.element = document.createElement('div');
        this.element.className = 'floating-element interactive-element medium';
        
        // Set content and styling based on type
        const config = this.getTypeConfig();
        this.element.innerHTML = config.content;
        this.element.style.left = this.x + 'px';
        this.element.style.top = this.y + 'px';
        this.element.style.position = 'absolute';
        this.element.style.cursor = 'pointer';
        this.element.style.pointerEvents = 'auto';
        this.element.style.fontSize = '2.5rem';
        this.element.style.filter = config.filter;
        this.element.style.transition = 'transform 0.1s ease-out, filter 0.3s ease';
        this.element.style.zIndex = '1001';
        
        // Add hover effect
        this.element.addEventListener('mouseenter', () => {
            this.element.style.transform = 'scale(1.2)';
            this.element.style.filter = config.hoverFilter;
        });
        
        this.element.addEventListener('mouseleave', () => {
            this.element.style.transform = 'scale(1)';
            this.element.style.filter = config.filter;
        });
        
        // Add click handler
        this.element.addEventListener('click', (e) => {
            e.stopPropagation();
            
            if (this.type === 'submit_score') {
                this.handleSubmitScore();
            } else {
                window.open(config.url, '_blank');
            }
            
            // Add click effect
            this.element.style.transform = 'scale(1.5)';
            this.element.style.filter = config.clickFilter;
            
            setTimeout(() => {
                this.element.style.filter = config.filter;
            }, 200);
        });
        
        const container = document.getElementById('floatingContainer');
        if (container) {
            container.appendChild(this.element);
        } else {
            console.error('floatingContainer not found for interactive element!');
        }
    }
    
    getTypeConfig() {
        const configs = {
            linkedin: {
                content: '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #0077B5; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.8em;">in</span>',
                filter: 'drop-shadow(0 0 10px rgba(0, 119, 181, 0.6))',
                hoverFilter: 'drop-shadow(0 0 15px rgba(0, 119, 181, 0.8))',
                clickFilter: 'drop-shadow(0 0 20px rgba(0, 119, 181, 1))',
                url: 'https://www.linkedin.com/in/alexstraughan/'
            },
            github: {
                content: '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #333; padding: 0.4em; border-radius: 0.1em; font-size: 0.8em; display: inline-flex; align-items: center; justify-content: center;"><svg width="16" height="16" viewBox="0 0 16 16" fill="white"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></span>',
                filter: 'drop-shadow(0 0 10px rgba(51, 51, 51, 0.6))',
                hoverFilter: 'drop-shadow(0 0 15px rgba(51, 51, 51, 0.8))',
                clickFilter: 'drop-shadow(0 0 20px rgba(51, 51, 51, 1))',
                url: 'https://github.com/alexstraughan'
            },
            email: {
                content: '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #D44638; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.8em;">@</span>',
                filter: 'drop-shadow(0 0 10px rgba(212, 70, 56, 0.6))',
                hoverFilter: 'drop-shadow(0 0 15px rgba(212, 70, 56, 0.8))',
                clickFilter: 'drop-shadow(0 0 20px rgba(212, 70, 56, 1))',
                url: 'mailto:alexstraughan.dev@gmail.com'
            },
            twitter: {
                content: '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #1DA1F2; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.8em;">X</span>',
                filter: 'drop-shadow(0 0 10px rgba(29, 161, 242, 0.6))',
                hoverFilter: 'drop-shadow(0 0 15px rgba(29, 161, 242, 0.8))',
                clickFilter: 'drop-shadow(0 0 20px rgba(29, 161, 242, 1))',
                url: 'https://twitter.com/alexstraughan'
            },
            portfolio: {
                content: '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #6366f1; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.8em;">üíº</span>',
                filter: 'drop-shadow(0 0 10px rgba(99, 102, 241, 0.6))',
                hoverFilter: 'drop-shadow(0 0 15px rgba(99, 102, 241, 0.8))',
                clickFilter: 'drop-shadow(0 0 20px rgba(99, 102, 241, 1))',
                url: 'https://straughan.dev'
            },
            submit_score: {
                content: this.getSubmitScoreContent(),
                filter: this.getSubmitScoreFilter(),
                hoverFilter: this.getSubmitScoreHoverFilter(),
                clickFilter: this.getSubmitScoreClickFilter(),
                url: '#'
            }
        };
        
        return configs[this.type] || configs.linkedin;
    }

    getSubmitScoreContent() {
        const playerName = localStorage.getItem('playerName');
        const scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';
        
        if (scoreSubmitted && playerName) {
            // Show player name with a different style
            return `<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #10b981; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.7em; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;">üë§ ${playerName}</span>`;
        } else {
            // Show submit score button
            return '<span style="font-family: Arial, sans-serif; font-weight: bold; color: white; background: #4facfe; padding: 0.2em 0.3em; border-radius: 0.1em; font-size: 0.8em;">üèÜ</span>';
        }
    }

    getSubmitScoreFilter() {
        const scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';
        return scoreSubmitted 
            ? 'drop-shadow(0 0 10px rgba(16, 185, 129, 0.6))'
            : 'drop-shadow(0 0 10px rgba(79, 172, 254, 0.6))';
    }

    getSubmitScoreHoverFilter() {
        const scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';
        return scoreSubmitted 
            ? 'drop-shadow(0 0 15px rgba(16, 185, 129, 0.8))'
            : 'drop-shadow(0 0 15px rgba(79, 172, 254, 0.8))';
    }

    getSubmitScoreClickFilter() {
        const scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';
        return scoreSubmitted 
            ? 'drop-shadow(0 0 20px rgba(16, 185, 129, 1))'
            : 'drop-shadow(0 0 20px rgba(79, 172, 254, 1))';
    }
    
    async handleSubmitScore() {
        let playerName = localStorage.getItem('playerName');
        let scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';
        
        // If already submitted, show info message instead
        if (scoreSubmitted && playerName) {
            alert(`Score tracking is active for ${playerName}. Your high score is automatically updated every 5 minutes!`);
            return;
        }
        
        if (!playerName) {
            playerName = prompt('Enter your name for the leaderboard:');
            if (!playerName || playerName.trim().length < 1) return;
            localStorage.setItem('playerName', playerName);
        }
        
        // Get score from game state
        let score = 0;
        if (window.game && window.game.state) {
            score = Math.floor(window.game.state.totalPointsEarned || window.game.state.points || 0);
        }
        
        if (score <= 0) {
            alert('You need to earn some points first!');
            return;
        }
        
        // Submit to backend
        try {
            await fetch('http://localhost:5678/submit_score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: playerName, score: score })
            });
            
            if (!scoreSubmitted) {
                localStorage.setItem('scoreSubmitted', 'true');
                this.startPeriodicScoreUpdate(playerName);
                // Update the element appearance
                this.updateSubmitScoreElement();
            }
            
            alert('Score submitted! You are now being tracked automatically every 5 minutes.');
        } catch (err) {
            alert('Failed to submit score.');
        }
    }
    
    updateSubmitScoreElement() {
        if (this.type === 'submit_score') {
            const config = this.getTypeConfig();
            this.element.innerHTML = config.content;
            this.element.style.filter = config.filter;
        }
    }
    
    startPeriodicScoreUpdate(playerName) {
        setInterval(async () => {
            if (!playerName) return;
            let score = 0;
            if (window.game && window.game.state) {
                score = Math.floor(window.game.state.totalPointsEarned || window.game.state.points || 0);
            }
            if (score <= 0) return;
            
            try {
                await fetch('http://localhost:5678/submit_score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: playerName, score: score })
                });
            } catch (err) {
                // Silent fail
            }
        }, 5 * 60 * 1000); // 5 minutes
    }
    
    startOrbiting(targetX, targetY) {
        this.isOrbiting = true;
        this.orbitTarget.x = targetX;
        this.orbitTarget.y = targetY;
        this.originalPosition.x = this.x;
        this.originalPosition.y = this.y;
        this.orbitCenterLocked = false; // Allow following mouse initially
    }
    
    lockOrbitCenter() {
        this.orbitCenterLocked = true; // Lock orbit center when mouse is released
    }
    
    stopOrbiting() {
        this.isOrbiting = false;
        this.orbitCenterLocked = false;
    }
    
    
    update(mouseX, mouseY, otherElements) {
        if (this.isOrbiting) {
            // Calculate distance to orbit target
            const dx = this.orbitTarget.x - this.x;
            const dy = this.orbitTarget.y - this.y;
            const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
            
            // If far from orbit center, move towards it
            if (distanceToTarget > this.orbitRadius + 20) {
                this.x += dx * this.moveToOrbitSpeed;
                this.y += dy * this.moveToOrbitSpeed;
            } else {
                // Orbit around the target
                this.orbitAngle += this.orbitSpeed;
                const orbitX = this.orbitTarget.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                const orbitY = this.orbitTarget.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                
                // Smoothly move to orbit position
                this.x += (orbitX - this.x) * 0.1;
                this.y += (orbitY - this.y) * 0.1;
            }
        } else {
            // Normal floating behavior when not orbiting
            this.angle += 0.002; // Very slow rotation
            this.vx = Math.cos(this.angle) * this.speedMultiplier;
            this.vy = Math.sin(this.angle) * this.speedMultiplier;
            
            // Apply movement
            this.x += this.vx;
            this.y += this.vy;
            
            // Boundary bouncing - just reverse direction smoothly
            const margin = this.radius;
            if (this.x < margin || this.x > window.innerWidth - margin) {
                this.angle = Math.PI - this.angle; // Reflect angle
                this.x = Math.max(margin, Math.min(window.innerWidth - margin, this.x));
            }
            if (this.y < margin || this.y > window.innerHeight - margin) {
                this.angle = -this.angle; // Reflect angle
                this.y = Math.max(margin, Math.min(window.innerHeight - margin, this.y));
            }
        }
        
        // Affect other elements (push them away) but don't be affected by them
        for (let i = 0; i < otherElements.length; i++) {
            const other = otherElements[i];
            if (other === this || other.isInteractive) continue;
            
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distanceSquared = dx * dx + dy * dy;
            const minDistance = this.radius + other.radius;
            const influenceDistanceSquared = (minDistance * 1.5) * (minDistance * 1.5);
            
            if (distanceSquared < influenceDistanceSquared && distanceSquared > 0) {
                // Push other elements away
                const distance = Math.sqrt(distanceSquared);
                const force = 2; // Stronger force
                const normalX = dx / distance;
                const normalY = dy / distance;
                
                other.vx -= normalX * force;
                other.vy -= normalY * force;
            }
        }
        
        // Batch DOM updates - only update if position changed significantly
        const deltaX = Math.abs(this.x - (this.lastX || this.x));
        const deltaY = Math.abs(this.y - (this.lastY || this.y));
        
        // Force update on first frame or if position changed significantly
        if (!this.lastX || !this.lastY || deltaX > 0.5 || deltaY > 0.5) {
            this.element.style.left = this.x + 'px';
            this.element.style.top = this.y + 'px';
            this.lastX = this.x;
            this.lastY = this.y;
        }
    }
}

// Legacy LinkedIn class for backward compatibility
class LinkedInElement extends InteractiveElement {
    constructor(x, y) {
        super('linkedin', x, y);
        this.isLinkedIn = true; // Keep for backward compatibility
    }
}

// Physics Manager
class Physics {
    constructor() {
        this.elements = [];
        this.interactiveElements = [];
        this.mouseX = window.innerWidth / 2;
        this.mouseY = window.innerHeight / 2;
        this.isMouseDown = false;
        this.orbitStartTime = 0;
        this.orbitStopTime = 0;
        this.isOrbiting = false;
        this.holdTimer = null; // Timer for hold delay
        this.holdDelay = 500; // 0.5 seconds in milliseconds
        this.emojis = [
            'üíª', 'üöÄ', '‚ö°', 'üéØ', '‚ú®', 'üîß', 'üí°', 'üé®', 'üì±', '‚öôÔ∏è',
            'üñ•Ô∏è', 'üìä', 'üåü', 'üíé', 'üîÆ', 'üé™', 'üé≠', 'üé®', 'üéØ',
            '‚≠ê', 'üåô', '‚òÑÔ∏è', 'ü™ê', 'üåà', 'üî•', 'üí´', '‚ú®', '‚ö°', 'üí•',
            'üéµ', 'üé∂', 'üéπ', 'üé∏', 'ü•Å', 'üé∫', 'üéª', 'üé§', 'üéß', 'üìª',
            'üéÆ', 'üïπÔ∏è', 'üé≤', 'üÉè', 'üéØ', 'üèÜ', 'ü•á', 'üèÖ', 'üéñÔ∏è', 'üëë',
            'üõ∏', 'üåç', 'üåå', '‚≠ê', 'üå†', 'üî≠', 'üõ∞Ô∏è', 'üåë', 'üåí', 'üåì'
        ];
        this.initializeEventListeners();
    }
    
    initializeEventListeners() {
        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            this.mouseX = e.clientX;
            this.mouseY = e.clientY;
            
            // If we're orbiting, update the orbit target (only if not locked)
            if (this.isOrbiting) {
                this.interactiveElements.forEach(element => {
                    if (element.isOrbiting && !element.orbitCenterLocked) {
                        element.orbitTarget.x = this.mouseX;
                        element.orbitTarget.y = this.mouseY;
                    }
                });
            }
        });
        
        // Mouse down - start orbiting for interactive elements after delay
        document.addEventListener('mousedown', (e) => {
            // Check if the click is on a UI element or button
            const target = e.target;
            const isUIElement = target.closest('.greeting-card') || 
                               target.closest('.game-hub') || 
                               target.closest('.tab-button') || 
                               target.closest('.skill-card') ||
                               target.classList.contains('interactive-element');
            
            if (!isUIElement) {
                this.isMouseDown = true;
                this.orbitStartTime = Date.now();
                
                // Clear any existing timer
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                }
                
                // Set timer for 0.5 second delay
                this.holdTimer = setTimeout(() => {
                    if (this.isMouseDown) { // Only start if still holding
                        this.isOrbiting = true;
                        
                        // Start orbiting for all interactive elements
                        this.interactiveElements.forEach(element => {
                            element.startOrbiting(this.mouseX, this.mouseY);
                        });
                        
                        console.log('Started orbiting interactive elements after hold delay');
                    }
                }, this.holdDelay);
            }
        });
        
        // Mouse up - stop orbiting after delay
        document.addEventListener('mouseup', () => {
            if (this.isMouseDown) {
                this.isMouseDown = false;
                
                // Clear the hold timer if mouse is released before delay
                if (this.holdTimer) {
                    clearTimeout(this.holdTimer);
                    this.holdTimer = null;
                }
                
                // Only proceed with orbit stopping if we were actually orbiting
                if (this.isOrbiting) {
                    this.orbitStopTime = Date.now();
                    
                    // Stop following mouse but continue orbiting at current position
                    this.interactiveElements.forEach(element => {
                        if (element.isOrbiting) {
                            // Lock the orbit center to current mouse position
                            element.lockOrbitCenter();
                        }
                    });
                    
                    // Continue orbiting for 1 second after mouse up
                    setTimeout(() => {
                        this.isOrbiting = false;
                        this.interactiveElements.forEach(element => {
                            element.stopOrbiting();
                        });
                        console.log('Stopped orbiting interactive elements');
                    }, 1000);
                }
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.elements.forEach(element => {
                if (element.x > window.innerWidth - element.radius) {
                    element.x = window.innerWidth - element.radius;
                }
                if (element.y > window.innerHeight - element.radius) {
                    element.y = window.innerHeight - element.radius;
                }
            });
        });
    }
    
    createFloatingElements() {
        // Reduce console logging for performance
        // console.log('Creating floating elements...');
        const numElements = 40; // Reduced slightly for better performance
        
        // Get actual viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // console.log('Viewport dimensions:', viewportWidth, 'x', viewportHeight);
        
        // Create interactive elements (LinkedIn, GitHub, Email, etc.)
        const interactiveTypes = ['linkedin', 'github', 'email', 'twitter', 'portfolio', 'submit_score'];
        const numInteractive = 6; // Create all 6 types
        
        for (let i = 0; i < numInteractive; i++) {
            const type = interactiveTypes[i];
            // Spread them around the screen
            const x = viewportWidth * 0.1 + Math.random() * viewportWidth * 0.8;
            const y = viewportHeight * 0.1 + Math.random() * viewportHeight * 0.8;
            
            const interactiveElement = new InteractiveElement(type, x, y);
            this.elements.push(interactiveElement);
            this.interactiveElements.push(interactiveElement);
        }
        // console.log('Created', numInteractive, 'interactive elements');
        
        // Create regular floating elements
        for (let i = 0; i < numElements; i++) {
            const emoji = this.emojis[Math.floor(Math.random() * this.emojis.length)];
            
            // Ensure elements don't spawn too close to edges
            const margin = 100;
            const x = margin + Math.random() * (viewportWidth - 2 * margin);
            const y = margin + Math.random() * (viewportHeight - 2 * margin);
            
            // Random sizes for variety
            const sizeRand = Math.random();
            const size = sizeRand < 0.15 ? 'large' : sizeRand < 0.7 ? 'medium' : 'small';
            
            this.elements.push(new FloatingElement(emoji, x, y, size));
        }
        
        // console.log('Created', this.elements.length, 'total floating elements');
    }
    
    // Animation loop with frame rate control
    animate() {
        // Limit to ~60fps by only updating every 16ms
        const now = performance.now();
        if (!this.lastFrameTime) this.lastFrameTime = now;
        
        if (now - this.lastFrameTime >= 16) {
            this.elements.forEach(element => {
                element.update(this.mouseX, this.mouseY, this.elements);
            });
            this.lastFrameTime = now;
            
            // Debug: Log every 60 frames (about once per second)
            if (!this.frameCount) this.frameCount = 0;
            this.frameCount++;
            if (this.frameCount % 60 === 0) {
                // console.log('Animation running, frame:', this.frameCount, 'elements:', this.elements.length);
            }
        }
        
        requestAnimationFrame(() => this.animate());
    }
    
    start() {
        console.log('Starting physics simulation...');
        this.createFloatingElements();
        console.log('Created', this.elements.length, 'total elements for animation');
        this.animate();
        console.log('Physics animation loop started');
        
        // Debug: Check if elements are actually in the DOM after a short delay
        setTimeout(() => {
            const container = document.getElementById('floatingContainer');
            if (container) {
                console.log('FloatingContainer found with', container.children.length, 'child elements');
                // Check if any elements have movement
                if (this.elements.length > 0) {
                    const firstElement = this.elements[0];
                    console.log('First element position:', firstElement.x, firstElement.y, 'velocity:', firstElement.vx, firstElement.vy);
                }
            } else {
                console.error('FloatingContainer not found in DOM!');
            }
        }, 1000);
    }
}

// Add leaderboard button and popup modal
window.addEventListener('DOMContentLoaded', () => {
    // Create leaderboard button
    const leaderboardBtn = document.createElement('button');
    leaderboardBtn.textContent = 'Leaderboard';
    leaderboardBtn.id = 'leaderboardBtn';
    leaderboardBtn.style.position = 'fixed';
    leaderboardBtn.style.top = '20px';
    leaderboardBtn.style.right = '20px';
    leaderboardBtn.style.zIndex = '2000';
    leaderboardBtn.style.padding = '0.7em 1.2em';
    leaderboardBtn.style.fontSize = '1.2em';
    leaderboardBtn.style.background = '#6366f1';
    leaderboardBtn.style.color = 'white';
    leaderboardBtn.style.border = 'none';
    leaderboardBtn.style.borderRadius = '0.4em';
    leaderboardBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    leaderboardBtn.style.cursor = 'pointer';
    document.body.appendChild(leaderboardBtn);

    // Create submit score button
    const submitScoreBtn = document.createElement('button');
    submitScoreBtn.textContent = 'Submit Score';
    submitScoreBtn.id = 'submitScoreBtn';
    submitScoreBtn.style.position = 'fixed';
    submitScoreBtn.style.top = '70px';
    submitScoreBtn.style.right = '20px';
    submitScoreBtn.style.zIndex = '2000';
    submitScoreBtn.style.padding = '0.7em 1.2em';
    submitScoreBtn.style.fontSize = '1.2em';
    submitScoreBtn.style.background = '#4facfe';
    submitScoreBtn.style.color = 'white';
    submitScoreBtn.style.border = 'none';
    submitScoreBtn.style.borderRadius = '0.4em';
    submitScoreBtn.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
    submitScoreBtn.style.cursor = 'pointer';
    document.body.appendChild(submitScoreBtn);

    let playerName = localStorage.getItem('playerName') || null;
    let scoreSubmitted = localStorage.getItem('scoreSubmitted') === 'true';

    // Hide button if already submitted
    if (scoreSubmitted) {
        submitScoreBtn.style.display = 'none';
    }

    // Submit score handler
    submitScoreBtn.addEventListener('click', async () => {
        playerName = prompt('Enter your name for the leaderboard:');
        if (!playerName || playerName.trim().length < 1) return;
        localStorage.setItem('playerName', playerName);
        
        // Get score from game state
        let score = 0;
        if (window.game && window.game.state) {
            score = Math.floor(window.game.state.totalPointsEarned || window.game.state.points || 0);
        }
        
        if (score <= 0) {
            alert('You need to earn some points first!');
            return;
        }
        
        // Submit to backend
        try {
            await fetch('http://localhost:5678/submit_score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: playerName, score: score })
            });
            submitScoreBtn.style.display = 'none';
            localStorage.setItem('scoreSubmitted', 'true');
            // Start periodic updates
            startPeriodicScoreUpdate();
            alert('Score submitted!');
        } catch (err) {
            alert('Failed to submit score.');
        }
    });

    // Periodic score update every 5 minutes
    function startPeriodicScoreUpdate() {
        setInterval(async () => {
            if (!playerName) return;
            let score = 0;
            if (window.game && window.game.state) {
                score = Math.floor(window.game.state.totalPointsEarned || window.game.state.points || 0);
            }
            if (score <= 0) return;
            
            try {
                await fetch('http://localhost:5678/submit_score', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: playerName, score: score })
                });
            } catch (err) {
                // Silent fail
            }
        }, 5 * 60 * 1000); // 5 minutes
    }

    // If already submitted, start periodic updates
    if (scoreSubmitted && playerName) {
        startPeriodicScoreUpdate();
    }

    // Create leaderboard backdrop
    const leaderboardBackdrop = document.createElement('div');
    leaderboardBackdrop.id = 'leaderboardBackdrop';
    leaderboardBackdrop.style.position = 'fixed';
    leaderboardBackdrop.style.top = '0';
    leaderboardBackdrop.style.left = '0';
    leaderboardBackdrop.style.width = '100%';
    leaderboardBackdrop.style.height = '100%';
    leaderboardBackdrop.style.background = 'rgba(0,0,0,0.6)';
    leaderboardBackdrop.style.zIndex = '2999';
    leaderboardBackdrop.style.display = 'none';
    leaderboardBackdrop.style.backdropFilter = 'blur(5px)';
    document.body.appendChild(leaderboardBackdrop);

    // Create leaderboard popup
    const leaderboardModal = document.createElement('div');
    leaderboardModal.id = 'leaderboardModal';
    leaderboardModal.style.position = 'fixed';
    leaderboardModal.style.top = '50%';
    leaderboardModal.style.left = '50%';
    leaderboardModal.style.transform = 'translate(-50%, -50%)';
    leaderboardModal.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
    leaderboardModal.style.padding = '2.5em';
    leaderboardModal.style.borderRadius = '1em';
    leaderboardModal.style.boxShadow = '0 20px 40px rgba(0,0,0,0.3), 0 10px 20px rgba(0,0,0,0.2)';
    leaderboardModal.style.zIndex = '3000';
    leaderboardModal.style.display = 'none';
    leaderboardModal.style.minWidth = '400px';
    leaderboardModal.style.maxWidth = '500px';
    leaderboardModal.style.color = 'white';
    leaderboardModal.style.fontFamily = '"Inter", "Segoe UI", "Roboto", sans-serif';
    leaderboardModal.innerHTML = `
        <h2 style="margin-top:0; margin-bottom:1.5em; text-align:center; font-size:2em; font-weight:700; text-shadow:2px 2px 4px rgba(0,0,0,0.3);">üèÜ Leaderboard</h2>
        <div id="leaderboardContent" style="background:rgba(255,255,255,0.15); padding:1.5em; border-radius:0.8em; backdrop-filter:blur(10px); border:1px solid rgba(255,255,255,0.2);">Loading...</div>
        <button id="closeLeaderboard" style="margin-top:2em; padding:0.8em 2em; background:rgba(255,255,255,0.2); color:white; border:2px solid rgba(255,255,255,0.3); border-radius:0.5em; cursor:pointer; font-weight:600; font-size:1.1em; transition:all 0.3s ease; backdrop-filter:blur(5px); width:100%;">Close</button>
    `;
    document.body.appendChild(leaderboardModal);

    // Add hover effects for close button
    const closeBtn = leaderboardModal.querySelector('#closeLeaderboard');
    closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.background = 'rgba(255,255,255,0.3)';
        closeBtn.style.borderColor = 'rgba(255,255,255,0.5)';
        closeBtn.style.transform = 'translateY(-2px)';
    });
    closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.background = 'rgba(255,255,255,0.2)';
        closeBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        closeBtn.style.transform = 'translateY(0px)';
    });

    // Show leaderboard popup
    leaderboardBtn.addEventListener('click', () => {
        leaderboardBackdrop.style.display = 'block';
        leaderboardModal.style.display = 'block';
        fetchLeaderboard();
    });
    
    // Close leaderboard popup
    closeBtn.addEventListener('click', () => {
        leaderboardBackdrop.style.display = 'none';
        leaderboardModal.style.display = 'none';
    });
    
    // Close on backdrop click
    leaderboardBackdrop.addEventListener('click', () => {
        leaderboardBackdrop.style.display = 'none';
        leaderboardModal.style.display = 'none';
    });

    // Fetch leaderboard data from backend
    function fetchLeaderboard() {
        fetch('http://localhost:5678/leaderboard')
            .then(res => res.json())
            .then(data => {
                const content = leaderboardModal.querySelector('#leaderboardContent');
                if (data.leaderboard && data.leaderboard.length > 0) {
                    const leaderboardHTML = data.leaderboard.map((entry, index) => {
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                        const nameStyle = index < 3 ? 'font-weight:700; text-shadow:1px 1px 2px rgba(0,0,0,0.3);' : 'font-weight:600;';
                        return `
                            <div style="display:flex; justify-content:space-between; align-items:center; padding:0.8em 1em; margin:0.5em 0; background:rgba(255,255,255,0.1); border-radius:0.5em; border-left:4px solid ${index < 3 ? '#FFD700' : 'rgba(255,255,255,0.3)'};">
                                <span style="display:flex; align-items:center; gap:0.8em;">
                                    <span style="font-size:1.2em; min-width:2em;">${medal}</span>
                                    <span style="${nameStyle}">${entry.name}</span>
                                </span>
                                <span style="font-size:1.1em; font-weight:700; color:#FFD700; text-shadow:1px 1px 2px rgba(0,0,0,0.3);">${entry.score.toLocaleString()}</span>
                            </div>
                        `;
                    }).join('');
                    content.innerHTML = leaderboardHTML;
                } else {
                    content.innerHTML = '<div style="text-align:center; padding:2em; color:rgba(255,255,255,0.8); font-style:italic;">No scores yet. Be the first to submit!</div>';
                }
            })
            .catch(() => {
                leaderboardModal.querySelector('#leaderboardContent').innerHTML = '<div style="text-align:center; padding:2em; color:rgba(255,255,255,0.8);">Failed to load leaderboard.</div>';
            });
    }
});

// Export the Physics class
window.Physics = Physics;
