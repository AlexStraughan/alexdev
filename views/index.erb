<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Straughan - Software Developer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .hero-section {
            text-align: center;
            color: white;
            z-index: 10;
            position: relative;
        }

        .name-title {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: fadeInUp 1s ease-out;
        }

        .subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            animation: fadeInUp 1s ease-out 0.3s both;
        }

        .interactive-greeting {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid rgba(255,255,255,0.2);
            animation: fadeInUp 1s ease-out 0.6s both;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .interactive-greeting:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.2);
        }

        .interactive-greeting:active {
            transform: translateY(-2px) scale(0.98);
            background: rgba(255,255,255,0.3);
        }

        .points-display {
            font-size: 1.8rem;
            font-weight: bold;
            color: #4facfe;
            margin-top: 1rem;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
        }

        .cps-display {
            font-size: 1rem;
            color: #00f2fe;
            margin-top: 0.5rem;
            opacity: 0.8;
        }

        .greeting-text {
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }

        .click-hint {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .achievement-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            font-weight: bold;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.5s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .achievement-popup.show {
            transform: translateX(0);
        }

        .milestone-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #4facfe;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(79, 172, 254, 0.8);
        }

        .skills-section {
            margin-top: 3rem;
            animation: fadeInUp 1s ease-out 0.9s both;
        }

        .skills-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            text-align: center;
            color: white;
        }

        .status-display {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .status-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 1rem 1.5rem;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 120px;
        }

        .status-title {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            margin-bottom: 0.5rem;
        }

        .status-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #4facfe;
            text-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
        }

        .tabs-container {
            display: flex;
            justify-content: center;
            margin-bottom: 2rem;
            gap: 1rem;
        }

        .tab-button {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            user-select: none;
        }

        .tab-button.active {
            background: rgba(79, 172, 254, 0.3);
            border-color: rgba(79, 172, 254, 0.6);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.3);
        }

        .tab-button:hover:not(.active) {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .skills-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }

        .skill-card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
            transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            opacity: 1;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .skill-card:hover:not(.locked) {
            transform: translateY(-3px) scale(1.02);
            background: rgba(255,255,255,0.15);
        }

        .skill-card:active:not(.locked) {
            transform: translateY(-1px) scale(1.01);
            background: rgba(255,255,255,0.25);
        }

        .skill-card.affordable {
            border-color: rgba(79, 172, 254, 0.6);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.3);
        }

        .skill-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .skill-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: white;
            margin-bottom: 0.5rem;
        }

        .skill-description {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            margin-bottom: 1rem;
        }

        .skill-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .skill-owned {
            color: #4facfe;
            font-weight: bold;
        }

        .skill-cost {
            color: #00f2fe;
            font-weight: bold;
        }

        .skill-production {
            color: #4facfe;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            opacity: 0.9;
        }

        .skill-bar {
            background: rgba(255,255,255,0.2);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .skill-progress {
            height: 100%;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            border-radius: 4px;
            transition: width 2s ease-out;
            width: 0%;
        }

        .floating-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .floating-element {
            position: absolute;
            color: rgba(255,255,255,0.15);
            font-size: 1.5rem;
            transition: all 0.1s ease-out;
            will-change: transform;
            user-select: none;
        }

        .floating-element.large {
            font-size: 2.5rem;
            color: rgba(255,255,255,0.2);
        }

        .floating-element.small {
            font-size: 1rem;
            color: rgba(255,255,255,0.1);
        }

        .floating-element.medium {
            font-size: 1.8rem;
            color: rgba(255,255,255,0.15);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInFromBottom {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes gentleFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .load-skills-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 25px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }

        .load-skills-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        @media (max-width: 768px) {
            .name-title {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1.2rem;
            }
            
            .container {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="floating-elements" id="floatingContainer">
            <!-- Floating elements will be generated by JavaScript -->
        </div>

        <div class="hero-section">
            <h1 class="name-title">Alex Straughan</h1>
            <p class="subtitle">Software Developer & Digital Craftsman</p>
            
            <div class="interactive-greeting" id="greetingCard">
                <div class="greeting-text" id="greetingText">Click me to earn Code Points! �</div>
                <div class="click-hint">Start your coding empire...</div>
                <div class="points-display" id="pointsDisplay">Code Points: 0</div>
                <div class="cps-display" id="cpsDisplay">Points per second: 0</div>
            </div>

            <div class="skills-section">
                <h2 class="skills-title">Development Hub</h2>
                
                <!-- Status Display -->
                <div class="status-display">
                    <div class="status-card">
                        <div class="status-title">💪 Click Power</div>
                        <div class="status-value" id="clickPowerDisplay">1</div>
                    </div>
                    <div class="status-card">
                        <div class="status-title">🖱️ Click Rate</div>
                        <div class="status-value" id="clickRateDisplay">0.0/s</div>
                    </div>
                    <div class="status-card">
                        <div class="status-title">⚡ Generator Multiplier</div>
                        <div class="status-value" id="generatorMultiplierDisplay">1x</div>
                    </div>
                    <div class="status-card">
                        <div class="status-title">📈 Total CPS</div>
                        <div class="status-value" id="totalCpsDisplay">0</div>
                    </div>
                </div>
                
                <div class="tabs-container">
                    <div class="tab-button active" onclick="switchTab('generators')">
                        🏭 Generators
                    </div>
                    <div class="tab-button" onclick="switchTab('upgrades')">
                        ⚡ Upgrades
                    </div>
                </div>

                <div id="generators" class="tab-content active">
                    <div class="skills-grid" id="skillsGrid">
                        <!-- Generators will be loaded automatically -->
                    </div>
                </div>

                <div id="upgrades" class="tab-content">
                    <div class="skills-grid" id="upgradesGrid">
                        <!-- Upgrades will be loaded automatically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Physics-based floating elements with space-like movement
        class FloatingElement {
            constructor(emoji, x, y, size = 'medium') {
                this.emoji = emoji;
                this.x = x;
                this.y = y;
                this.size = size;
                this.vx = (Math.random() - 0.5) * 2; // Random initial velocity
                this.vy = (Math.random() - 0.5) * 2;
                this.element = null;
                this.mass = size === 'large' ? 4 : size === 'small' ? 1 : 2;
                this.radius = size === 'large' ? 25 : size === 'small' ? 15 : 20;
                this.maxSpeed = size === 'large' ? 3 : size === 'small' ? 5 : 4;
                this.mouseRepelForce = size === 'large' ? 8 : size === 'small' ? 12 : 10;
                this.mouseRepelDistance = size === 'large' ? 150 : size === 'small' ? 100 : 120;
                
                this.createElement();
            }
            
            createElement() {
                this.element = document.createElement('div');
                this.element.className = `floating-element ${this.size}`;
                this.element.textContent = this.emoji;
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.position = 'absolute';
                document.getElementById('floatingContainer').appendChild(this.element);
            }
            
            update(mouseX, mouseY, otherElements) {
                // Mouse repulsion
                const mouseDx = this.x - mouseX;
                const mouseDy = this.y - mouseY;
                const mouseDistance = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                
                if (mouseDistance < this.mouseRepelDistance && mouseDistance > 0) {
                    const repelForce = (this.mouseRepelDistance - mouseDistance) / this.mouseRepelDistance;
                    const pushStrength = repelForce * this.mouseRepelForce;
                    
                    this.vx += (mouseDx / mouseDistance) * pushStrength / this.mass;
                    this.vy += (mouseDy / mouseDistance) * pushStrength / this.mass;
                }
                
                // Element-to-element collisions
                otherElements.forEach(other => {
                    if (other !== this) {
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = this.radius + other.radius;
                        
                        if (distance < minDistance && distance > 0) {
                            // Calculate collision response
                            const overlap = minDistance - distance;
                            const separationX = (dx / distance) * overlap * 0.5;
                            const separationY = (dy / distance) * overlap * 0.5;
                            
                            // Separate the objects
                            this.x -= separationX;
                            this.y -= separationY;
                            other.x += separationX;
                            other.y += separationY;
                            
                            // Calculate bounce velocities
                            const relativeVx = other.vx - this.vx;
                            const relativeVy = other.vy - this.vy;
                            const impulse = 2 * (relativeVx * dx + relativeVy * dy) / (distance * (this.mass + other.mass));
                            
                            this.vx += impulse * other.mass * dx / distance;
                            this.vy += impulse * other.mass * dy / distance;
                            other.vx -= impulse * this.mass * dx / distance;
                            other.vy -= impulse * this.mass * dy / distance;
                            
                            // Add some energy to make it more dynamic
                            const energyBoost = 0.1;
                            this.vx *= (1 + energyBoost);
                            this.vy *= (1 + energyBoost);
                            other.vx *= (1 + energyBoost);
                            other.vy *= (1 + energyBoost);
                        }
                    }
                });
                
                // Apply movement
                this.x += this.vx;
                this.y += this.vy;
                
                // Speed limiting
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }
                
                // Boundary bouncing with energy conservation
                const margin = this.radius;
                if (this.x < margin) {
                    this.x = margin;
                    this.vx = Math.abs(this.vx) * 0.8; // Slight energy loss on bounce
                }
                if (this.x > window.innerWidth - margin) {
                    this.x = window.innerWidth - margin;
                    this.vx = -Math.abs(this.vx) * 0.8;
                }
                if (this.y < margin) {
                    this.y = margin;
                    this.vy = Math.abs(this.vy) * 0.8;
                }
                if (this.y > window.innerHeight - margin) {
                    this.y = window.innerHeight - margin;
                    this.vy = -Math.abs(this.vy) * 0.8;
                }
                
                // Add slight random movement to keep things interesting
                if (Math.random() < 0.002) {
                    this.vx += (Math.random() - 0.5) * 0.1;
                    this.vy += (Math.random() - 0.5) * 0.1;
                }
                
                // Update element position
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                
                // Add rotation based on velocity for extra visual appeal
                const rotation = Math.atan2(this.vy, this.vx) * (180 / Math.PI);
                this.element.style.transform = `rotate(${rotation * 0.1}deg)`;
            }
        }
        
        // Create floating elements
        const floatingElements = [];
        const emojis = [
            '💻', '🚀', '⚡', '🎯', '✨', '🔧', '💡', '🎨', '📱', '⚙️',
            '🖥️', '📊', '🌟', '💎', '🔮', '🎪', '🎭', '🎨', '🎯',
            '⭐', '🌙', '☄️', '🪐', '🌈', '🔥', '💫', '✨', '⚡', '💥',
            '🎵', '🎶', '🎹', '🎸', '🥁', '🎺', '🎻', '🎤', '🎧', '📻',
            '🎮', '🕹️', '🎲', '🃏', '🎯', '🏆', '🥇', '🏅', '🎖️', '👑',
            '🛸', '🌍', '🌌', '⭐', '🌠', '🔭', '🛰️', '🌑', '🌒', '🌓'
        ];
        
        function createFloatingElements() {
            const numElements = 45; // Reduced slightly for better performance with collisions
            
            // Get actual viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            for (let i = 0; i < numElements; i++) {
                const emoji = emojis[Math.floor(Math.random() * emojis.length)];
                
                // Ensure elements don't spawn too close to edges
                const margin = 100;
                const x = margin + Math.random() * (viewportWidth - 2 * margin);
                const y = margin + Math.random() * (viewportHeight - 2 * margin);
                
                // Random sizes for variety
                const sizeRand = Math.random();
                const size = sizeRand < 0.15 ? 'large' : sizeRand < 0.7 ? 'medium' : 'small';
                
                floatingElements.push(new FloatingElement(emoji, x, y, size));
            }
        }
        
        // Mouse tracking
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            floatingElements.forEach(element => {
                if (element.x > window.innerWidth - element.radius) {
                    element.x = window.innerWidth - element.radius;
                }
                if (element.y > window.innerHeight - element.radius) {
                    element.y = window.innerHeight - element.radius;
                }
            });
        });
        
        // Animation loop
        function animate() {
            floatingElements.forEach(element => {
                element.update(mouseX, mouseY, floatingElements);
            });
            requestAnimationFrame(animate);
        }

        // Achievement system
        function checkAchievements() {
            const totalGenerators = Object.values(gameState.generators).reduce((sum, count) => sum + count, 0);
            
            achievements.forEach(achievement => {
                if (!gameState.achievements.includes(achievement.id)) {
                    let earned = false;
                    
                    switch (achievement.type) {
                        case 'clicks':
                            earned = gameState.totalClicks >= achievement.requirement;
                            break;
                        case 'points':
                            earned = gameState.totalPointsEarned >= achievement.requirement;
                            break;
                        case 'generators':
                            earned = totalGenerators >= achievement.requirement;
                            break;
                        case 'cps':
                            earned = gameState.pointsPerSecond >= achievement.requirement;
                            break;
                    }
                    
                    if (earned) {
                        gameState.achievements.push(achievement.id);
                        showAchievement(achievement);
                        saveGameState();
                    }
                }
            });
        }

        // Show achievement popup
        function showAchievement(achievement) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div>🏆 Achievement Unlocked!</div>
                <div><strong>${achievement.name}</strong></div>
                <div style="font-size: 0.9rem; opacity: 0.9;">${achievement.description}</div>
            `;
            
            document.body.appendChild(popup);
            
            // Show animation
            setTimeout(() => popup.classList.add('show'), 100);
            
            // Hide after 4 seconds
            setTimeout(() => {
                popup.classList.remove('show');
                setTimeout(() => document.body.removeChild(popup), 500);
            }, 4000);
        }

        // Milestone celebration
        function showMilestone(text) {
            const milestone = document.createElement('div');
            milestone.className = 'milestone-effect';
            milestone.textContent = text;
            document.body.appendChild(milestone);
            
            let scale = 0;
            let opacity = 1;
            const animate = () => {
                scale += 0.05;
                opacity -= 0.02;
                milestone.style.transform = `translate(-50%, -50%) scale(${scale})`;
                milestone.style.opacity = opacity;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(milestone);
                }
            };
            requestAnimationFrame(animate);
        }

        // Purchase effect
        function createPurchaseEffect(icon) {
            const effect = document.createElement('div');
            effect.textContent = icon;
            effect.style.position = 'fixed';
            effect.style.fontSize = '3rem';
            effect.style.pointerEvents = 'none';
            effect.style.zIndex = '1000';
            effect.style.left = '50%';
            effect.style.top = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            
            document.body.appendChild(effect);
            
            let scale = 0.5;
            let rotation = 0;
            let opacity = 1;
            const animate = () => {
                scale += 0.1;
                rotation += 20;
                opacity -= 0.05;
                effect.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${rotation}deg)`;
                effect.style.opacity = opacity;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(effect);
                }
            };
            requestAnimationFrame(animate);
        }

        // Click particles
        function createClickParticles() {
            const colors = ['#4facfe', '#00f2fe', '#ffffff'];
            const particles = 8;
            
            for (let i = 0; i < particles; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.width = '6px';
                particle.style.height = '6px';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.borderRadius = '50%';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '999';
                
                const greetingCard = document.getElementById('greetingCard');
                const rect = greetingCard.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = (rect.top + rect.height / 2) + 'px';
                
                document.body.appendChild(particle);
                
                const angle = (Math.PI * 2 * i) / particles;
                const velocity = 5 + Math.random() * 3;
                let x = 0;
                let y = 0;
                let opacity = 1;
                
                const animate = () => {
                    x += Math.cos(angle) * velocity;
                    y += Math.sin(angle) * velocity;
                    opacity -= 0.05;
                    
                    particle.style.transform = `translate(${x}px, ${y}px)`;
                    particle.style.opacity = opacity;
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        document.body.removeChild(particle);
                    }
                };
                requestAnimationFrame(animate);
            }
        }

        // Screen shake effect
        function addScreenShake() {
            const container = document.querySelector('.container');
            container.style.animation = 'none';
            container.style.transform = 'translate(0)';
            
            setTimeout(() => {
                container.style.animation = 'shake 0.5s ease-in-out';
            }, 10);
            
            setTimeout(() => {
                container.style.animation = 'none';
                container.style.transform = 'translate(0)';
            }, 500);
        }

        // Add shake animation to CSS
        const shakeCSS = `
            @keyframes shake {
                0%, 100% { transform: translate(0); }
                10% { transform: translate(-2px, -1px); }
                20% { transform: translate(2px, 1px); }
                30% { transform: translate(-1px, 2px); }
                40% { transform: translate(1px, -2px); }
                50% { transform: translate(-2px, 1px); }
                60% { transform: translate(2px, -1px); }
                70% { transform: translate(-1px, -2px); }
                80% { transform: translate(1px, 2px); }
                90% { transform: translate(-2px, -1px); }
            }
        `;
        
        const style = document.createElement('style');
        style.textContent = shakeCSS;
        document.head.appendChild(style);
        
        // Initialize everything when page loads
        window.addEventListener('load', () => {
            createFloatingElements();
            animate();
            initializeGame();
            
            // Original page fade-in effect
            document.body.style.opacity = '0';
            document.body.style.transition = 'opacity 0.5s ease-in';
            setTimeout(() => {
                document.body.style.opacity = '1';
            }, 100);
        });

        // Cookie Clicker Game Implementation
        let gameState = {
            points: 0,
            pointsPerSecond: 0,
            generators: {},
            clickPower: 1,
            totalClicks: 0,
            totalPointsEarned: 0,
            achievements: [],
            upgrades: {},
            clicksPerSecond: 0,
            lastClickTime: Date.now(),
            recentClicks: []
        };

        let generatorData = [];
        let upgradeData = [
            {
                id: "double_click",
                name: "Better Mouse",
                description: "Double your clicking power!",
                cost: 100,
                effect: "clickMultiplier",
                value: 2,
                icon: "🖱️"
            },
            {
                id: "super_click",
                name: "Mechanical Keyboard",
                description: "5x clicking power for the pros!",
                cost: 1000,
                effect: "clickMultiplier",
                value: 5,
                icon: "⌨️"
            },
            {
                id: "junior_boost",
                name: "Coffee for Juniors",
                description: "Junior Developers work 2x faster",
                cost: 500,
                effect: "generatorMultiplier",
                value: 2,
                icon: "☕"
            },
            {
                id: "senior_boost",
                name: "Premium IDE",
                description: "Senior Developers work 2x faster",
                cost: 5000,
                effect: "generatorMultiplier",
                value: 2,
                icon: "💻"
            },
            {
                id: "monkey_boost",
                name: "Banana Supply",
                description: "Code Monkeys work 2x faster",
                cost: 50000,
                effect: "generatorMultiplier",
                value: 2,
                icon: "🍌"
            },
            {
                id: "ai_boost",
                name: "Neural Network Upgrade",
                description: "AI Assistants work 2x faster",
                cost: 500000,
                effect: "generatorMultiplier",
                value: 2,
                icon: "🧠"
            }
        ];
        let achievements = [
            { id: "first_click", name: "First Steps", description: "Make your first click", requirement: 1, type: "clicks" },
            { id: "hundred_clicks", name: "Clicking Master", description: "Click 100 times", requirement: 100, type: "clicks" },
            { id: "thousand_points", name: "Coder", description: "Earn 1,000 points", requirement: 1000, type: "points" },
            { id: "first_generator", name: "Automation Begins", description: "Buy your first generator", requirement: 1, type: "generators" },
            { id: "ten_generators", name: "Small Team", description: "Own 10 generators total", requirement: 10, type: "generators" },
            { id: "million_points", name: "Code Millionaire", description: "Earn 1,000,000 points", requirement: 1000000, type: "points" },
            { id: "hundred_per_second", name: "Efficient Coder", description: "Generate 100 points per second", requirement: 100, type: "cps" }
        ];

        // Load game state from localStorage
        function loadGameState() {
            const saved = localStorage.getItem('codeClickerSave');
            if (saved) {
                gameState = { ...gameState, ...JSON.parse(saved) };
            }
        }

        // Save game state to localStorage
        function saveGameState() {
            localStorage.setItem('codeClickerSave', JSON.stringify(gameState));
        }

        // Initialize the game
        async function initializeGame() {
            loadGameState();
            await loadGenerators();
            calculatePointsPerSecond();
            updateDisplay();
            startGameLoop();
        }

        // Load generators from API
        async function loadGenerators() {
            try {
                const response = await fetch('/api/generators');
                const data = await response.json();
                generatorData = data.generators;
                
                // Initialize generator counts if not loaded from save
                generatorData.forEach(gen => {
                    if (!(gen.id in gameState.generators)) {
                        gameState.generators[gen.id] = 0;
                    }
                });
                
                // Initialize upgrade states
                upgradeData.forEach(upgrade => {
                    if (!(upgrade.id in gameState.upgrades)) {
                        gameState.upgrades[upgrade.id] = false;
                    }
                });
                
                renderGenerators();
                renderUpgrades();
                
                // Initialize with generators tab active
                switchTab('generators');
            } catch (error) {
                console.error('Error loading generators:', error);
            }
        }

        // Calculate current cost of a generator (increases with each purchase)
        function getGeneratorCost(generator) {
            const owned = gameState.generators[generator.id] || 0;
            return Math.floor(generator.baseCost * Math.pow(1.15, owned));
        }

        // Calculate total production per second
        function calculatePointsPerSecond() {
            let total = 0;
            const generatorMultiplier = getGeneratorMultiplier();
            
            generatorData.forEach(gen => {
                const owned = gameState.generators[gen.id] || 0;
                total += owned * gen.baseProduction * generatorMultiplier;
            });
            
            // Add clicking rate to total CPS
            const clickingCPS = gameState.clicksPerSecond * gameState.clickPower;
            gameState.pointsPerSecond = total + clickingCPS;
        }

        // Update clicking rate based on recent clicks
        function updateClickingRate() {
            const now = Date.now();
            const timeWindow = 1000; // Reduced to 1 second window for ultra-fast response
            
            // Remove clicks older than time window
            gameState.recentClicks = gameState.recentClicks.filter(clickTime => 
                now - clickTime < timeWindow
            );
            
            // Calculate clicks per second
            gameState.clicksPerSecond = gameState.recentClicks.length / (timeWindow / 1000);
            
            // Recalculate total CPS and update display immediately
            calculatePointsPerSecond();
            updateDisplay(); // Update the main display to show new CPS immediately
        }

        // Render generator cards
        function renderGenerators() {
            const skillsGrid = document.getElementById('skillsGrid');
            skillsGrid.innerHTML = '';
            
            generatorData.forEach((generator, index) => {
                const owned = gameState.generators[generator.id] || 0;
                const cost = getGeneratorCost(generator);
                const affordable = gameState.points >= cost;
                const effectiveProduction = generator.baseProduction * getGeneratorMultiplier();
                
                const generatorCard = document.createElement('div');
                generatorCard.className = `skill-card ${affordable ? 'affordable' : 'locked'}`;
                generatorCard.setAttribute('data-generator-id', generator.id);
                
                // Use mousedown for more responsive clicking
                generatorCard.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    buyGenerator(generator.id);
                });
                
                generatorCard.innerHTML = `
                    <div class="skill-icon">${generator.icon}</div>
                    <div class="skill-name">${generator.name}</div>
                    <div class="skill-description">${generator.description}</div>
                    <div class="skill-stats">
                        <span class="skill-owned">Owned: ${owned}</span>
                        <span class="skill-cost">Cost: ${formatNumber(cost)}</span>
                    </div>
                    <div class="skill-production">
                        Produces ${formatNumber(effectiveProduction)} points/sec each
                        ${getGeneratorMultiplier() > 1 ? `(${formatNumber(generator.baseProduction)} base × ${getGeneratorMultiplier().toFixed(1)})` : ''}
                    </div>
                `;
                
                skillsGrid.appendChild(generatorCard);
            });
        }

        // Render upgrades
        function renderUpgrades() {
            const upgradesContainer = document.getElementById('upgradesGrid');
            upgradesContainer.innerHTML = '';
            upgradeData.forEach(upgrade => {
                const isPurchased = gameState.upgrades[upgrade.id];
                if (isPurchased) return; // Hide purchased upgrades
                
                const affordable = gameState.points >= upgrade.cost;
                const upgradeCard = document.createElement('div');
                upgradeCard.className = `skill-card ${affordable ? 'affordable' : 'locked'}`;
                
                upgradeCard.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    buyUpgrade(upgrade.id);
                });
                
                upgradeCard.innerHTML = `
                    <div class="skill-icon">${upgrade.icon}</div>
                    <div class="skill-name">${upgrade.name}</div>
                    <div class="skill-description">${upgrade.description}</div>
                    <div class="skill-stats">
                        <span class="skill-cost">Cost: ${formatNumber(upgrade.cost)}</span>
                    </div>
                `;
                
                upgradesContainer.appendChild(upgradeCard);
            });
        }

        // Tab switching function
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }

        // Buy a generator
        function buyGenerator(generatorId) {
            const generator = generatorData.find(g => g.id === generatorId);
            const cost = getGeneratorCost(generator);
            
            if (gameState.points >= cost) {
                gameState.points -= cost;
                gameState.generators[generatorId] = (gameState.generators[generatorId] || 0) + 1;
                
                calculatePointsPerSecond();
                updateDisplay();
                renderGenerators(); // Only re-render when actually buying
                renderUpgrades(); // Update upgrades display too
                saveGameState();
                
                // Add some visual feedback
                createFloatingNumber(`+${generator.name}!`, '#4facfe');
                
                // Check achievements
                checkAchievements();
                
                // Satisfying purchase effect
                createPurchaseEffect(generator.icon);
                
                // Add screen shake for expensive purchases
                if (cost > 10000) {
                    addScreenShake();
                }
            }
        }

        // Buy an upgrade
        function buyUpgrade(upgradeId) {
            const upgrade = upgradeData.find(u => u.id === upgradeId);
            
            if (gameState.points >= upgrade.cost && !gameState.upgrades[upgradeId]) {
                gameState.points -= upgrade.cost;
                gameState.upgrades[upgradeId] = true;
                
                // Apply upgrade effects
                applyUpgradeEffects(upgradeId);
                
                // Full update cycle
                calculatePointsPerSecond();
                updateDisplay();
                renderUpgrades(); // Refresh upgrades display
                renderGenerators(); // Update generators too in case multipliers changed
                saveGameState();
                
                // Add visual feedback
                createFloatingNumber(`+${upgrade.name}!`, '#ff6b6b');
                
                // Check achievements
                checkAchievements();
                
                // Satisfying purchase effect
                createPurchaseEffect(upgrade.icon);
                
                // Add screen shake for expensive upgrades
                if (upgrade.cost > 50000) {
                    addScreenShake();
                }
            }
        }

        // Apply upgrade effects
        function applyUpgradeEffects(upgradeId) {
            const upgrade = upgradeData.find(u => u.id === upgradeId);
            if (upgrade.effect === 'clickMultiplier') {
                gameState.clickPower *= upgrade.value;
            }
            // Recalculate points per second after upgrade
            calculatePointsPerSecond();
        }

        // Get current generator multiplier from upgrades
        function getGeneratorMultiplier() {
            let multiplier = 1;
            upgradeData.forEach(upgrade => {
                if (gameState.upgrades[upgrade.id] && upgrade.effect === 'generatorMultiplier') {
                    multiplier *= upgrade.value;
                }
            });
            return multiplier;
        }

        // Update status display
        function updateStatusDisplay() {
            document.getElementById('clickPowerDisplay').textContent = formatNumber(gameState.clickPower);
            document.getElementById('clickRateDisplay').textContent = gameState.clicksPerSecond.toFixed(1) + '/s';
            document.getElementById('generatorMultiplierDisplay').textContent = getGeneratorMultiplier().toFixed(1) + 'x';
            document.getElementById('totalCpsDisplay').textContent = formatNumber(gameState.pointsPerSecond);
        }

        // Format large numbers
        function formatNumber(num) {
            if (num < 1000) return Math.floor(num).toString();
            if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
            if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
            if (num < 1000000000000) return (num / 1000000000).toFixed(1) + 'B';
            return (num / 1000000000000).toFixed(1) + 'T';
        }

        // Update display
        function updateDisplay() {
            document.getElementById('pointsDisplay').textContent = `Code Points: ${formatNumber(gameState.points)}`;
            document.getElementById('cpsDisplay').textContent = `Points per second: ${formatNumber(gameState.pointsPerSecond)}`;
            updateStatusDisplay();
        }

        // Create floating number effect with variety
        function createFloatingNumber(text, color) {
            const floatingNum = document.createElement('div');
            floatingNum.textContent = text;
            floatingNum.style.position = 'fixed';
            floatingNum.style.color = color;
            floatingNum.style.fontSize = '1.5rem';
            floatingNum.style.fontWeight = 'bold';
            floatingNum.style.pointerEvents = 'none';
            floatingNum.style.zIndex = '1000';
            floatingNum.style.textShadow = '0 0 10px rgba(79, 172, 254, 0.5)';
            
            const greetingCard = document.getElementById('greetingCard');
            const rect = greetingCard.getBoundingClientRect();
            
            // Add variety to starting position
            const randomX = (Math.random() - 0.5) * 100; // ±50px horizontal spread
            floatingNum.style.left = (rect.left + rect.width / 2 + randomX) + 'px';
            floatingNum.style.top = (rect.top + rect.height / 2) + 'px';
            
            document.body.appendChild(floatingNum);
            
            // Animate the floating number with variety
            let y = 0;
            let x = (Math.random() - 0.5) * 60; // Random horizontal drift ±30px
            let opacity = 1;
            const driftSpeed = (Math.random() - 0.5) * 0.8; // Random horizontal drift speed
            
            const animate = () => {
                y -= 2 + Math.random() * 1; // Slightly variable upward speed
                x += driftSpeed;
                opacity -= 0.015 + Math.random() * 0.01; // Slightly variable fade speed
                
                floatingNum.style.transform = `translate(${x}px, ${y}px)`;
                floatingNum.style.opacity = opacity;
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    document.body.removeChild(floatingNum);
                }
            };
            requestAnimationFrame(animate);
        }

        // Main game loop
        function startGameLoop() {
            // Main game loop - runs every 100ms
            setInterval(() => {
                // Add points from generators
                gameState.points += gameState.pointsPerSecond / 10; // Update 10 times per second
                gameState.totalPointsEarned += gameState.pointsPerSecond / 10;
                
                updateDisplay();
                
                // Auto-save every 10 seconds
                if (Math.random() < 0.01) {
                    saveGameState();
                }
                
                // Only update generator affordability, don't re-render everything
                updateGeneratorAffordability();
                
                // Check achievements periodically
                if (Math.random() < 0.1) {
                    checkAchievements();
                }
            }, 100);
            
            // Ultra-fast update loop for clicking rate - runs every 16ms (~60fps) for instant feedback
            setInterval(() => {
                updateClickingRate();
                updateStatusDisplay(); // Update just the status display for click rate
            }, 16);
            
            // Save every 30 seconds
            setInterval(saveGameState, 30000);
        }

        // Update only the affordability styling without re-rendering
        function updateGeneratorAffordability() {
            // Update generator cards
            const generatorCards = document.querySelectorAll('#skillsGrid .skill-card');
            generatorCards.forEach((card, index) => {
                if (generatorData[index]) {
                    const generator = generatorData[index];
                    const cost = getGeneratorCost(generator);
                    const affordable = gameState.points >= cost;
                    
                    // Update cost display
                    const costElement = card.querySelector('.skill-cost');
                    if (costElement) {
                        costElement.textContent = `Cost: ${formatNumber(cost)}`;
                    }
                    
                    // Update affordability class
                    if (affordable && !card.classList.contains('affordable')) {
                        card.classList.add('affordable');
                        card.classList.remove('locked');
                    } else if (!affordable && !card.classList.contains('locked')) {
                        card.classList.remove('affordable');
                        card.classList.add('locked');
                    }
                }
            });
            
            // Update upgrade cards
            const upgradeCards = document.querySelectorAll('#upgradesGrid .skill-card');
            upgradeCards.forEach((card, index) => {
                const visibleUpgrades = upgradeData.filter(upgrade => !gameState.upgrades[upgrade.id]);
                if (visibleUpgrades[index]) {
                    const upgrade = visibleUpgrades[index];
                    const affordable = gameState.points >= upgrade.cost;
                    
                    // Update affordability class
                    if (affordable && !card.classList.contains('affordable')) {
                        card.classList.add('affordable');
                        card.classList.remove('locked');
                    } else if (!affordable && !card.classList.contains('locked')) {
                        card.classList.remove('affordable');
                        card.classList.add('locked');
                    }
                }
            });
        }

        // Interactive greeting functionality (now the main clicker)
        document.getElementById('greetingCard').addEventListener('click', async () => {
            try {
                // Track click timing
                const now = Date.now();
                gameState.recentClicks.push(now);
                gameState.lastClickTime = now;
                
                // Add points for clicking
                gameState.points += gameState.clickPower;
                gameState.totalClicks++;
                gameState.totalPointsEarned += gameState.clickPower;
                
                createFloatingNumber(`+${gameState.clickPower}`, '#00f2fe');
                
                // Random greeting update
                const response = await fetch('/api/greeting');
                const data = await response.json();
                document.getElementById('greetingText').textContent = data.greeting;
                
                // Update clicking rate and display
                updateClickingRate();
                updateDisplay();
                updateGeneratorAffordability(); // Use the lighter update function
                checkAchievements();
                
                // Add click particle effect
                createClickParticles();
                
                // Milestone celebrations
                if (gameState.totalPointsEarned % 1000 === 0 && gameState.totalPointsEarned > 0) {
                    showMilestone(`${formatNumber(gameState.totalPointsEarned)} Points!`);
                }
            } catch (error) {
                console.error('Error:', error);
            }
        });
    </script>
</body>
</html>
